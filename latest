# shellcheck shell=sh disable=SC2039,SC3043 # xrc

# author:       Li Junhao           l@x-cmd.com

___X_CMD_JSON_AWK_PATH="$(xrc which json/lib/v0_walk.awk)"

# Section: main

# TODO: Using subcmd module to enhance.

___x_cmd_json(){
    local op="${1}";    [ "$#" -ge 1 ] && shift 1

    case "$op" in
        help|"")            xrc cat json/lib/help.txt >&2    ;;
        var)                ___x_cmd_json_var           "$@" ;;
        color)              ___x_cmd_json_color         "$@" ;;
        push|append)        ___x_cmd_json_push          "$@" ;;
        unshift|prepend)    ___x_cmd_json_prepend       "$@" ;;
        put)                ___x_cmd_json_put           "$@" ;;
        keys)               ___x_cmd_json_keys          "$@" ;;
        values)             ___x_cmd_json_values        "$@" ;;
        query)              ___x_cmd_json_query         "$@" ;;
        del)                ___x_cmd_json_del           "$@" ;;
        shift)              ___x_cmd_json_shift         "$@" ;;
        pop)                ___x_cmd_json_pop           "$@" ;;
        length)             ___x_cmd_json_length        "$@" ;;
        unescape)           ___x_cmd_json_unescape      "$@" ;;
        data)               ___x_cmd_json_data          "$@" ;;
        *)                  ___x_cmd_json_query         "$op" "$@" ;;
    esac
}

# EndSection

# Section: data
___x_cmd_json_data(){
    ___x_cmd_curl_gitx x-cmd json-test-data main data/one.mb.json "${TMPDIR}/mb1.json"
    seq "${1:-1}" | x args 1 - cat "${TMPDIR}/mb1.json"
}
# EndSection

# Section: functions

# We have a better design
___x_cmd_json_var(){
    local varname="${1:?Provide variable name}"
    shift
    local s
    if [ $# -ne 0 ]; then
        s="$(awk -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"$@\"))
A
)"
    else
        s="$(awk -f "$___X_CMD_JSON_AWK_PATH" -)"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

___x_cmd_json_color(){
    if [ "$1" ]; then
        local varname="${1:?Provide variable name}"
        awk -v format=1 -v color=1 -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v format=1 -v color=1 -f "$___X_CMD_JSON_AWK_PATH" -
    fi
}

# aaa.push()
___x_cmd_json_push(){ ___x_cmd_json_append "$@"; }

# aaa.append()
___x_cmd_json_append(){
    local keypath="${1:?Provide variable name}"
    local opv2="${2:?Provide value}"

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"
    [ "$varname" = "$keypath" ] && opv1="."
    shift 2

    local s
    if [ "$varname" ]; then
        s="$(awk -v op=append -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=append -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# aaa.prepend("value")
___x_cmd_json_unshift(){ ___x_cmd_json_prepend "$@"; }
___x_cmd_json_prepend(){
    local keypath=${1:?Provide variable name}
    local opv2="${2:?Provide value}"

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    shift 2

    local s
    if [ "$varname" ]; then
        s="$(awk -v op=prepend -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=prepend -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# jo b.b= 2

: <<'DOCTEST'
> b={a:1}
> ___x_cmd_json_put b.b 2
> echo "$b"
{"a":1,"b":"2"}
DOCTEST
___x_cmd_json_put(){
    local keypath="${1:?Provide variable name}"
    local opv2="${2:?Provide value}"
    shift 2

    local varname="${keypath%%.*}"
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    local s
    if [ "$varname" ]; then
        s="$(awk -v op=put -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)"
    else
        s="$(awk -v op=put -v opv1="$opv1" -v opv2="$opv2" -f "$___X_CMD_JSON_AWK_PATH")"
    fi
    local code=$?
    if [ $code -eq 0 ]; then eval "$varname=\"\$s\""
    else return 1;  fi
}

# jo b.b
: <<'DOCTEST'
> b=[1,2,3]
> ___x_cmd_json_values b
1
2
3
DOCTEST
___x_cmd_json_values(){
    local op=values
    if [ "$1" = "-r" ]; then
        op="values-r"
        shift
    fi

    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1=""
    # TODO: why？Seems wrong
    # shift 2

    local s
    if [ "$varname" ]; then
        awk -v op="$op" -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op="$op" -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH"
    fi
}

: <<'DOCTEST'
> b={a:1,b:2,c:3}
> ___x_cmd_json_values b
a
b
c
DOCTEST
___x_cmd_json_keys(){
    local op=keys
    if [ "$1" = "-r" ]; then
        op=keys-r
        shift
    fi

    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1=""
    # TODO: why？Seems wrong
    # shift 2

    local s
    if [ "$varname" ]; then
        awk -v op="$op" -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op="$op" -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH"
    fi
}

# jo b.b
___x_cmd_json_query(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        awk -v op=extract -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op=extract -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" -
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> ___x_cmd_json_del b.[0]
> echo $b  # ___x_cmd_json_del
[2,3]
DOCTEST
___x_cmd_json_del(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        if s="$(awk -v op=del -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            [ -n "$t" ] && printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=del -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" | tail -n 1
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> ___x_cmd_json_shift b
> echo $b; # ___x_cmd_json_shift
[2,3]
DOCTEST
___x_cmd_json_shift(){
    local keypath=${1:?Provide variable name}

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."
    # shift 2

    if [ "$varname" ]; then
        if s="$(awk -v op=shift -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=shift -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" | tail -n 1
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> ___x_cmd_json_length b
3
DOCTEST
___x_cmd_json_length(){
    local keypath="${1:?Provide variable name}"; shift

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."

    if [ "$varname" ]; then
        awk -v op=length -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
    else
        awk -v op=length -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH"
    fi
}

: <<'DOCTEST'
> b=[1,2,3]
> ___x_cmd_json_pop b
> echo $b # ___x_cmd_json_pop
[1,2]
DOCTEST

# TODO: json pop b :a  # values stored in symbol a
# TODO: json pop b @a  # all values stored in array b
___x_cmd_json_pop(){
    local keypath="${1:?Provide variable name}"; shift

    local varname=${keypath%%.*}
    local opv1=".${keypath#*.}"

    [ "$varname" = "$keypath" ] && opv1="."

    local s
    if [ "$varname" ]; then
        if s="$(awk -v op=pop -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" <<A
$(eval echo $(printf "%s" \"\$"${varname}"\"))
A
)";     then
            local t=""
            while read -r s; do
                t+="$s"
            done <<A
$s
A
            printf "%s\n" "$t"
            eval "$varname=\"\$t\""
        else return 1;  fi
    else
        awk -v op=pop -v opv1="$opv1" -f "$___X_CMD_JSON_AWK_PATH" | tail -n 1
    fi
}

# EndSection

# Section: serialize and unserialize

___x_cmd_json_flat(){
    awk -v op=flat-leaf -f "$___X_CMD_JSON_AWK_PATH"
}


# ___x_cmd_json_list 1 2 3 true false "\"true\"" hello "Working\"a"
# ___x_cmd_json_list <<A
# 1
# 2
# 3
# true
# false
# "true"
# hello
# Working\"a
# A
# ___x_cmd_json_list '[ 1, 2, 3, "true", true, false, hello"Working, it\'s working ]'


___x_cmd_json_array(){
    local s=
    while [ $# -gt 0 ]; do
        case "$1" in
            true|false|null)    s="$s,$1"   ;;
            [*)                 s="$s,$1";;
            \{*)                s="$s,$1";;
            # =\"*)             s="$2,${1:1}"   ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$1" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]];
                    then s="$s,$1" ;
                    else s="$s,\"${1//\"/\\\"}\"" ;
                    fi
                else
                    s="$(printf "%s" "$z" | awk -v s="$s" '{if($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){ s= s "," $0 ; }else{ gsub("\"","\\\"",$0);  s=s "," $0; }}END{print s}')"
                fi
                ;;
        esac
        shift
    done
    printf "%s" "[${s#?}]"
}


if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then

# Actually, it could works in ash. But we don't know how to detect ash environment.
___x_cmd_json_escape(){
    local a="${1:?Provide string}"
    a="$(echo "${a//$'\\'/\\}")"
    a="$(echo "${a//$'\n'/\\n}")"
    a="$(echo "${a//$'\r'/\\n}")"
    a="$(echo "${a//$'\t'/\\t}")"
    a="$(echo "${a//$'\b'/\\b}")"
    a="$(echo "${a//\"/\\\"}")"
    echo "\"$a\""
}

else

# Using awk for posix sh
___x_cmd_json_escape(){
    # Notice, if RS="\033", extra endline exsits because of bug in awk.
    awk '
BEGIN{
    RS=""   # RS="\003"
}
{
    a=$0
    gsub(/\"/, "\\\"", a)
    gsub(/\n/, "\\n", a)
    gsub(/\r/, "\\r", a)
    gsub(/\b/, "\\b", a)
    gsub(/\t/, "\\t", a)
    gsub(/\v/, "\\v", a)
    printf("\"%s\"", a)
}
' <<A
${1:?Provide string}
A
}

fi

# Posix sh version?
___x_cmd_json_unescape(){
    if [ $# -gt 0 ]; then
        eval echo "$@"
    else
        while read -r line; do
            eval echo -e "$line"
        done
    fi
}

# Reference: https://github.com/jpmens/jo/blob/master/jo.md
___x_cmd_json_dict(){
    printf "{\n"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ',\n'
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$(___x_cmd_json_escape "$value")"
    done
    printf "\n}"
}

___x_cmd_json_dict_compact(){
    printf "{"

    local key value
    local first=0
    for i in "$@"; do
        if [ "$first" -eq 0 ]; then
            first=1
        else
            printf ','
        fi

        key=${i%%=*}
        if [ "$key" != "$i" ]; then
            value=${i#*=}

            case "$value" in
            true|false|null|\{*\}|\[*\]|\"*)
                printf '%s:%s' "$(___x_cmd_json_escape "$key")" "$value" ;;
            *)
                if [ -z "${BASH_VERSION}${ZSH_VERSION}${KSH_VERSION}" ]; then
                    if [[ "$value" =~ ^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$ ]]; then
                            printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                else
                    if [ "$(printf "%s" "$value" | awk '{if ($0 ~ /^[+-]?[0-9]+(.[0-9]+)*([eE][0-9]+(.[0-9]+))*$/){print "1";}else{print "0";} }' )" = "1" ]; then
                        printf '  %s: %s' "$(___x_cmd_json_escape "$key")" "$value"
                    else
                        printf '  %s: %s' "$key" "$(___x_cmd_json_escape "$value")"
                    fi
                fi
            esac
            continue
        fi

        key=${i%%\:*}
        value=${i#*\:}
        printf '%s: %s' "$(___x_cmd_json_escape "$key")" "$(___x_cmd_json_escape "$value")"
    done
    printf "}"
}


# Scheme 1:
# out_color_key = "\033[0;35m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;32m"
# out_color_null = "\033[0;33m"   # "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 2:
# out_color_key = "\033[1;34m"
# out_color_string = "\033[0;33m"
# out_color_number = "\033[1;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# Scheme 3:
# out_color_key = "\033[1;33m"
# out_color_string = "\033[0;34m"
# out_color_number = "\033[0;35m"
# out_color_null = "\033[0;31m"
# out_color_true = "\033[7;32m"
# out_color_false = "\033[7;31m"

# TODO:array
# ___x_cmd_json_awk_color1(){
#     local IFS=$' '
#     A=(
#     -v out_color_key="\033[0;35m"
#     -v out_color_string="\033[0;34m"
#     -v out_color_number="\033[0;32m"
#     -v out_color_null="\033[0;33m"
#     -v out_color_true="\033[7;32m"
#     -v out_color_false="\033[7;31m"
#     )
#     echo "${A[*]}"
# }

# TODO: Using JSON
# TODO: array
# ___x_cmd_json_table(){
#     local n="${1:?Provide colume number}"
#     shift
#     local arr=() final=() idx=0 line IFS

#     if [ $# -gt 0 ]; then
#         for line in "$@"; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(___x_cmd_json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi

#         done
#     else
#         while read -r line; do
#             (( idx ++ ))
#             arr+=("$line")
#             if [ "$idx" -eq "$n" ]; then
#                 final+=("$(___x_cmd_json_array "${arr[@]}")")
#                 arr=()
#                 idx=0
#             fi
#         done
#     fi
#     ___x_cmd_json_array "${final[@]}"
# }

# ___x_cmd_json_attrlist(){
#     local arr=() final=() idx=0 line IFS var
#     eval var="\$${idx}"
#     while read -r line; do
#         (( idx ++ ))
#         arr+=("$var=$line")
#         if [ "$idx" -eq "$#" ]; then
#             final+=("$(___x_cmd_json_dict "${arr[@]}")")
#             arr=()
#             idx=0
#         fi
#     done

#     ___x_cmd_json_array "${final[@]}"
# }


# Move to json library
___x_cmd_json_from_kv(){
    local first=0
    local k v

    local IFS=$'\n'
    # Using consider using environment.
    local PARSE_KEY_STR="$*"

    while :; do
        read -r k || break
        read -r v || break

        if [ "$first" -eq 0 ]; then
            printf "{\n"
            first=1
        else
            printf ',\n'
        fi

        if echo "$PARSE_KEY_STR" | grep -q "$k"; then
            # TODO: using float
            if [ "$(printf "%s" "$v" | awk '{if ($0 ~ /^[1-9]+([0-9])*$/){print "1";}else{print "0";} }' )" = "1" ] || [ "$v" = true ] || [ "$v" = false ]; then
                printf '  "%s": %s' "$k" "$v"
                continue
            fi
        fi

        printf '  "%s": "%s"' "$k" "$v"
    done
    [ $first -ne 0 ] && printf "\n}"
}

# Simply json stringify
# ___x_cmd_json_from_kv(){
#     printf "{\n"
#     local first=0
#     local k v
#     for i in $(list.print); do

#         if [ "$first" -eq 0 ]; then
#             first=1
#         else
#             printf ',\n'
#         fi

#         k=$(echo -n "$i" | cut -d ':' -f 1)
#         v=$(echo -n "$i" | cut -d ':' -f 2)

#         printf '  "%s": "%s"' "$(str.unbase64 "$k")" "$(str.unbase64 "$v")"
#     done
#     printf "\n}"
# }

# EndSection

xrc json/lib/awk

xrc setmain ___x_cmd_json
